<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VoiceMorph Studio</title>
    <style>
        :root {
            --bg-dark: #121212;
            --bg-surface: #1e1e1e;
            --primary: #bb86fc;
            --primary-variant: #3700b3;
            --secondary: #03dac6;
            --error: #cf6679;
            --text-main: #ffffff;
            --text-muted: #b0b0b0;
            --border: #333;
        }

        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-dark);
            color: var(--text-main);
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            max-width: 800px;
            width: 100%;
            background-color: var(--bg-surface);
            padding: 30px;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            gap: 24px;
        }

        header {
            text-align: center;
            border-bottom: 1px solid var(--border);
            padding-bottom: 20px;
        }

        h1 {
            margin: 0;
            font-weight: 300;
            letter-spacing: 2px;
            color: var(--primary);
        }

        h2 {
            font-size: 1.1rem;
            color: var(--text-muted);
            margin-top: 5px;
            font-weight: 400;
        }

        /* Controls Grid */
        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 25px;
        }

        .panel {
            background: rgba(255, 255, 255, 0.03);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid var(--border);
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            font-weight: 600;
            color: var(--secondary);
        }

        /* Sliders */
        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.9rem;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 6px;
            background: #333;
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: var(--primary);
            border-radius: 50%;
            cursor: pointer;
            transition: background 0.2s, transform 0.2s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: #dbaaf9;
            transform: scale(1.1);
        }

        /* Switches */
        .switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 20px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #444;
            transition: .4s;
            border-radius: 20px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked+.slider {
            background-color: var(--primary);
        }

        input:checked+.slider:before {
            transform: translateX(20px);
        }

        /* Buttons */
        .btn-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            background-color: var(--primary-variant);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.95rem;
            transition: background 0.2s, transform 0.1s;
            flex-grow: 1;
        }

        button:hover {
            background-color: var(--primary);
        }

        button:active {
            transform: scale(0.98);
        }

        button.secondary {
            background-color: #333;
        }

        button.secondary:hover {
            background-color: #444;
        }

        button.record-btn {
            background-color: var(--error);
            width: 100%;
        }

        button.record-btn.recording {
            animation: pulse 1.5s infinite;
            background-color: red;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.4);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(255, 0, 0, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(255, 0, 0, 0);
            }
        }

        /* Visualizer */
        canvas {
            width: 100%;
            height: 100px;
            background-color: #000;
            border-radius: 8px;
            border: 1px solid var(--border);
        }

        /* Warning */
        .warning {
            font-size: 0.8rem;
            color: var(--text-muted);
            text-align: center;
            border-top: 1px solid var(--border);
            padding-top: 15px;
        }

        .status {
            text-align: center;
            height: 20px;
            color: var(--secondary);
            font-size: 0.9rem;
        }

        .presets {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
        }

        .preset-btn {
            font-size: 0.8rem;
            padding: 6px 12px;
            background: transparent;
            border: 1px solid var(--border);
        }

        .preset-btn.active {
            background: var(--secondary);
            color: #000;
            border-color: var(--secondary);
        }
    </style>
</head>

<body>

    <div class="container">
        <header>
            <h1>VOICEMORPH STUDIO</h1>
            <h2>Real-time Web Audio Voice Changer</h2>
        </header>

        <canvas id="visualizer"></canvas>
        <div class="status" id="status-text">Ready. Click 'Start Mic' to begin.</div>

        <div class="panel" style="display: flex; gap: 10px; flex-direction: column;">
            <button id="start-btn">üéôÔ∏è Start Microphone</button>
            <div class="control-group" id="output-dev-container" style="display:none; margin-bottom: 0;">
                <label>
                    <span>Output Device (e.g. Virtual Cable)</span>
                </label>
                <select id="output-select"
                    style="width: 100%; padding: 8px; border-radius: 4px; background: #333; color: white; border: 1px solid #444; margin-bottom: 8px;">
                    <option value="">Default Output</option>
                </select>
                <div style="display: flex; gap: 5px;">
                    <button id="refresh-dev-btn" class="secondary" style="padding: 5px; font-size: 0.8rem;">üîÑ
                        Refresh</button>
                    <button id="test-audio-btn" class="secondary" style="padding: 5px; font-size: 0.8rem;">üîä Test
                        Sound</button>
                </div>
                <div style="font-size: 0.75rem; color: #888; margin-top: 4px;">
                    On Mobile: Output is handled by OS. Webpages cannot inject audio into Phone Calls.
                </div>
            </div>

            <button id="quick-toggle-btn" class="secondary"
                style="margin-top: 10px; background-color: #03dac6; color: #000; font-weight: bold; height: 50px; font-size: 1.1rem;">
                SWITCH TO FEMALE
            </button>
        </div>

        <div class="controls-grid">
            <!-- Effects Panel -->
            <div class="panel">
                <div class="panel-header">
                    <span>Effects</span>
                    <label class="switch">
                        <input type="checkbox" id="monitor-toggle">
                        <span class="slider"></span>
                    </label>
                </div>

                <div class="presets">
                    <button class="preset-btn active" data-preset="normal">Normal</button>
                    <button class="preset-btn" data-preset="feminine">Feminine</button>
                    <button class="preset-btn" data-preset="masculine">Masculine</button>
                    <button class="preset-btn" data-preset="robot">Robot</button>
                </div>

                <div class="control-group">
                    <label>
                        <span>Pitch Shift</span>
                        <span id="pitch-val">0</span>
                    </label>
                    <input type="range" id="pitch-slider" min="-12" max="12" step="0.5" value="0">
                </div>

                <div class="control-group">
                    <label>
                        <span>Echo / Reverb</span>
                        <span id="echo-val">0%</span>
                    </label>
                    <input type="range" id="echo-slider" min="0" max="0.8" step="0.05" value="0">
                </div>

                <div class="control-group">
                    <label>
                        <span>Robot Modulation</span>
                        <span>On/Off</span>
                    </label>
                    <label class="switch">
                        <input type="checkbox" id="robot-toggle">
                        <span class="slider"></span>
                    </label>
                </div>

                <div class="control-group">
                    <label>
                        <span>Noise Gate</span>
                        <span>On/Off</span>
                    </label>
                    <label class="switch">
                        <input type="checkbox" id="gate-toggle" checked>
                        <span class="slider"></span>
                    </label>
                </div>
            </div>

            <!-- Recorder Panel -->
            <div class="panel">
                <div class="panel-header">
                    <span>Recording studio</span>
                </div>

                <div style="display: flex; flex-direction: column; gap: 15px;">
                    <button id="record-btn" class="record-btn" disabled>Start Recording</button>

                    <audio id="audio-player" controls style="width: 100%; display: none;"></audio>

                    <div class="btn-group">
                        <button id="download-btn" class="secondary" disabled>Download WAV (WebM)</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="warning">
            ‚ö†Ô∏è Disclaimer: For entertainment and accessibility purposes only. Do not use for impersonation or illegal
            activities.
        </div>
    </div>

    <script>
        // --- Audio Context & State ---
        let audioCtx;
        let micSource;
        let workletNode; // Pitch shifter
        let gainNode; // Master volume
        let monitorGain; // Live monitoring
        let analyser;
        let robotOsc;
        let robotGain;
        let dryNode, wetNode; // For mixing robot effect
        let delayNode, delayFeedback; // Echo
        let filterNode; // EQ
        let gateNode; // DynamicsCompressor acting as hard limit/gate or specific script
        let recorder;
        let recordedChunks = [];
        let recordStreamDest;

        // UI Elements
        const startBtn = document.getElementById('start-btn');
        const monitorToggle = document.getElementById('monitor-toggle');
        const pitchSlider = document.getElementById('pitch-slider');
        const pitchVal = document.getElementById('pitch-val');
        const echoSlider = document.getElementById('echo-slider');
        const echoVal = document.getElementById('echo-val');
        const robotToggle = document.getElementById('robot-toggle');
        const gateToggle = document.getElementById('gate-toggle');
        const statusText = document.getElementById('status-text');
        const canvas = document.getElementById('visualizer');
        const canvasCtx = canvas.getContext('2d');
        const presetBtns = document.querySelectorAll('.preset-btn');

        const recordBtn = document.getElementById('record-btn');
        const audioPlayer = document.getElementById('audio-player');
        const downloadBtn = document.getElementById('download-btn');
        const quickToggleBtn = document.getElementById('quick-toggle-btn');

        let isRecording = false;
        let currentVoiceState = 'normal'; // 'normal' or 'morphed'

        quickToggleBtn.addEventListener('click', () => {
            // If context not started, start it
            if (!audioCtx || audioCtx.state === 'suspended') {
                if (startBtn) startBtn.click();
            }

            if (currentVoiceState === 'normal') {
                // Switch to Feminine
                applyPreset('feminine');
                currentVoiceState = 'morphed';
                quickToggleBtn.innerText = "SWITCH TO NORMAL";
                quickToggleBtn.style.backgroundColor = "#bb86fc"; // Primary purple
                quickToggleBtn.style.color = "#fff";

                // Highlight preset btn
                presetBtns.forEach(b => b.classList.remove('active'));
                document.querySelector('button[data-preset="feminine"]').classList.add('active');

            } else {
                // Switch to Normal
                applyPreset('normal');
                currentVoiceState = 'normal';
                quickToggleBtn.innerText = "SWITCH TO FEMALE";
                quickToggleBtn.style.backgroundColor = "#03dac6"; // Secondary teal
                quickToggleBtn.style.color = "#000";

                // Highlight preset btn
                presetBtns.forEach(b => b.classList.remove('active'));
                document.querySelector('button[data-preset="normal"]').classList.add('active');
            }
        });

        // --- Worklet Blob URL ---
        // We inject the AudioWorklet processor code directly via a Blob to keep this single-file.

        // Actually, I'll use a very specific, simpler algorithm for the Worklet:
        // Just a Ring Buffer where Read Head moves at `rate` speed. 
        // When Read Head passes Write Head, we fade out/in to a new offset.
        // High Quality Pitch Shifter using Dual Delay-Line (Overlap-Add)
        // This reduces the 'tremolo' artifact of single-window granular synthesis.
        // --- Audio Engine: ScriptProcessorNode (Legacy) ---
        // We use ScriptProcessor because AudioWorklet's 'addModule' often fails 
        // on local file:// protocol due to CORS/Origin restrictions.
        // This ensures the code RUNS regardless of how the file is opened.

        let scriptProcessor;
        let pitchBuffer;
        let pitchBufferPtr = 0;
        let pitchPhase = 0;
        let currentPitch = 0;
        let targetPitch = 0; // For smoothing parameter changes

        let loFilter, midFilter, hiFilter; // Formant Filter Chain

        // Presets updated for Formant Shaping
        const presets = {
            normal: {
                pitch: 0, echo: 0, robot: false,
                eq: { lF: 200, lG: 0, mF: 1000, mG: 0, hF: 4000, hG: 0 }
            },
            feminine: {
                pitch: 4.0, // Targeted Pitch
                echo: 0, robot: false,
                // Formant Strategy:
                // 1. Cut Lows (Male Chest): LowShelf @ 160Hz, -10dB
                // 2. Reduce Mud: Peaking @ 500Hz, -4dB
                // 3. Boost Presence: HighShelf @ 3500Hz, +5dB
                eq: { lF: 160, lG: -10, mF: 500, mG: -4, hF: 3500, hG: 5 }
            },
            masculine: {
                pitch: -3.5,
                echo: 0, robot: false,
                // Boost chest, cut highs
                eq: { lF: 150, lG: 8, mF: 500, mG: 4, hF: 3000, hG: -6 }
            },
            robot: {
                pitch: -1, echo: 0.3, robot: true,
                eq: { lF: 200, lG: 0, mF: 1000, mG: 0, hF: 4000, hG: 0 }
            }
        };

        async function initAudio() {
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();

                // Mic Input
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false
                    }
                });

                statusText.innerText = "Microphone Active";
                startBtn.disabled = true;
                startBtn.classList.add('secondary');
                startBtn.innerText = "Active";
                recordBtn.disabled = false;

                // --- Build Graph ---
                micSource = audioCtx.createMediaStreamSource(stream);

                // 1. Pitch Shifter (ScriptProcessor)
                // Buffer size 4096 = ~92ms latency, good balance for JS perf
                scriptProcessor = audioCtx.createScriptProcessor(4096, 1, 1);

                // Initialize Pitch Buffer (Larger for safety)
                const bufSize = 16384;
                pitchBuffer = new Float32Array(bufSize);
                pitchBufferPtr = 0;

                scriptProcessor.onaudioprocess = (audioProcessingEvent) => {
                    const inputBuffer = audioProcessingEvent.inputBuffer;
                    const outputBuffer = audioProcessingEvent.outputBuffer;
                    const inputData = inputBuffer.getChannelData(0);
                    const outputData = outputBuffer.getChannelData(0);

                    // Smooth parameter
                    // Move currentPitch towards targetPitch
                    if (Math.abs(targetPitch - currentPitch) > 0.01) {
                        currentPitch += (targetPitch - currentPitch) * 0.1;
                    } else {
                        currentPitch = targetPitch;
                    }

                    // DSP Logic (Same as Dual-Delay)
                    if (Math.abs(currentPitch) < 0.1) {
                        outputData.set(inputData);

                        // Keep buffer updated even in bypass to avoid clicks on engage
                        for (let i = 0; i < inputData.length; i++) {
                            pitchBuffer[pitchBufferPtr] = inputData[i];
                            pitchBufferPtr = (pitchBufferPtr + 1) % bufSize;
                        }
                        return;
                    }

                    const sampleRate = audioCtx.sampleRate;
                    const windowSize = 0.05;
                    const overlap = windowSize * sampleRate;
                    const ratio = Math.pow(2, currentPitch / 12);
                    const phaseInc = (1 - ratio) / overlap;

                    for (let i = 0; i < inputData.length; i++) {
                        // Write
                        pitchBuffer[pitchBufferPtr] = inputData[i];

                        // Read
                        let phaseA = pitchPhase;
                        let phaseB = (pitchPhase + 0.5) % 1.0;

                        let gainA = 1.0 - 2.0 * Math.abs(phaseA - 0.5);
                        let gainB = 1.0 - 2.0 * Math.abs(phaseB - 0.5);

                        const delayA = phaseA * overlap;
                        const delayB = phaseB * overlap;

                        let rIdxA = pitchBufferPtr - delayA;
                        let rIdxB = pitchBufferPtr - delayB;

                        // Wrap
                        while (rIdxA < 0) rIdxA += bufSize;
                        while (rIdxB < 0) rIdxB += bufSize;

                        // Cubic/Linear Interp
                        let valA = getSample(pitchBuffer, rIdxA, bufSize);
                        let valB = getSample(pitchBuffer, rIdxB, bufSize);

                        outputData[i] = valA * gainA + valB * gainB;

                        // Increment
                        pitchBufferPtr = (pitchBufferPtr + 1) % bufSize;
                        pitchPhase += phaseInc;
                        if (pitchPhase >= 1.0) pitchPhase -= 1.0;
                        if (pitchPhase < 0.0) pitchPhase += 1.0;
                    }
                };

                function getSample(buf, idx, len) {
                    let i = Math.floor(idx);
                    let f = idx - i;
                    let s1 = buf[i % len];
                    let s2 = buf[(i + 1) % len];
                    return s1 * (1 - f) + s2 * f;
                }

                // 2. Formant EQ Chain
                loFilter = audioCtx.createBiquadFilter();
                midFilter = audioCtx.createBiquadFilter();
                hiFilter = audioCtx.createBiquadFilter();

                // Defaults (AllPass / Flat)
                loFilter.type = 'lowshelf'; loFilter.frequency.value = 200; loFilter.gain.value = 0;
                midFilter.type = 'peaking'; midFilter.frequency.value = 1000; midFilter.gain.value = 0;
                hiFilter.type = 'highshelf'; hiFilter.frequency.value = 4000; hiFilter.gain.value = 0;

                // 3. Robot Effect
                robotOsc = audioCtx.createOscillator();
                robotOsc.frequency.value = 50;
                robotOsc.start();
                const robotCarrierGain = audioCtx.createGain();
                robotCarrierGain.gain.value = 1.0;

                // 4. Echo
                delayNode = audioCtx.createDelay();
                delayFeedback = audioCtx.createGain();
                delayNode.delayTime.value = 0.0;
                delayFeedback.gain.value = 0.4;
                delayNode.connect(delayFeedback);
                delayFeedback.connect(delayNode);

                // Master Gain
                gainNode = audioCtx.createGain();
                monitorGain = audioCtx.createGain();
                monitorGain.gain.value = 0;

                // Visualizer
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 256;

                // --- Routing ---
                micSource.connect(scriptProcessor);
                scriptProcessor.connect(loFilter);
                loFilter.connect(midFilter);
                midFilter.connect(hiFilter);
                hiFilter.connect(robotCarrierGain);

                // Old filterNode.connect(robotCarrierGain) replaced by above chain

                function enableRobot(enable) {
                    if (enable) {
                        robotCarrierGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.01);
                        robotOsc.connect(robotCarrierGain.gain);
                    } else {
                        try { robotOsc.disconnect(robotCarrierGain.gain); } catch (e) { }
                        robotCarrierGain.gain.setTargetAtTime(1, audioCtx.currentTime, 0.01);
                    }
                }

                robotCarrierGain.connect(delayNode);
                robotCarrierGain.connect(gainNode);
                delayNode.connect(gainNode);

                gainNode.connect(analyser);
                analyser.connect(monitorGain);
                monitorGain.connect(audioCtx.destination);

                // Recorder
                recordStreamDest = audioCtx.createMediaStreamDestination();
                analyser.connect(recordStreamDest);

                recorder = new MediaRecorder(recordStreamDest.stream);
                recorder.ondataavailable = e => recordedChunks.push(e.data);
                recorder.onstop = exportRecording;

                window.setRobotEffect = enableRobot;
                drawVisualizer();

            } catch (err) {
                console.error(err);
                statusText.innerText = "Error: " + err.message;
                statusText.style.color = "var(--error)";
            }
        }

        const outputSelect = document.getElementById('output-select');
        const outputDevContainer = document.getElementById('output-dev-container');
        const refreshDevBtn = document.getElementById('refresh-dev-btn');
        const testAudioBtn = document.getElementById('test-audio-btn');

        // --- Output Device Selection (Chrome/Edge only) ---
        async function initOutputDevices() {
            try {
                // Ensure permission is granted (initAudio handles getUserMedia)
                const devices = await navigator.mediaDevices.enumerateDevices();
                const outputs = devices.filter(d => d.kind === 'audiooutput');

                // Show container if outputs found OR if we want to show the mobile warning
                outputDevContainer.style.display = 'block';

                // Save current selection
                const currentVal = outputSelect.value;
                outputSelect.innerHTML = '<option value="">Default System Output</option>';

                if (outputs.length > 0) {
                    outputs.forEach(dev => {
                        const opt = document.createElement('option');
                        opt.value = dev.deviceId;
                        opt.innerText = dev.label || `Speaker ${dev.deviceId.substr(0, 4)}...`;
                        outputSelect.appendChild(opt);
                    });
                    if (currentVal) outputSelect.value = currentVal;
                } else {
                    const opt = document.createElement('option');
                    opt.disabled = true;
                    opt.innerText = "No specific outputs found (Mobile/Restricted)";
                    outputSelect.appendChild(opt);
                }
            } catch (e) {
                console.error("Error listing output devices:", e);
            }
        }

        outputSelect.addEventListener('change', async (e) => {
            const deviceId = e.target.value;
            if (!audioCtx) return;
            try {
                if (typeof audioCtx.setSinkId === 'function') {
                    await audioCtx.setSinkId(deviceId);
                } else if (audioCtx.destination.setSinkId) {
                    await audioCtx.destination.setSinkId(deviceId);
                }
            } catch (err) {
                console.error("Error setting output device:", err);
            }
        });

        refreshDevBtn.addEventListener('click', initOutputDevices);

        testAudioBtn.addEventListener('click', () => {
            // Play a simple beep through the current context/output
            if (!audioCtx) initAudio();
            const osc = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            osc.connect(g);
            g.connect(audioCtx.destination);

            osc.frequency.setValueAtTime(440, audioCtx.currentTime);
            osc.type = 'sine';
            g.gain.setValueAtTime(0.5, audioCtx.currentTime);
            g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);

            osc.start();
            osc.stop(audioCtx.currentTime + 0.5);
        });

        // Wrap initAudio to include device enumeration
        const originalInit = initAudio;
        initAudio = async function () {
            await originalInit();
            initOutputDevices();
        };

        // --- Controls ---

        startBtn.addEventListener('click', () => {
            // Resume context if suspended (browser requirements)
            if (audioCtx && audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
            if (!audioCtx) initAudio();
        });

        // Monitor
        monitorToggle.addEventListener('change', (e) => {
            if (monitorGain) {
                monitorGain.gain.setTargetAtTime(e.target.checked ? 1 : 0, audioCtx.currentTime, 0.1);
            }
        });

        // Pitch Slider
        pitchSlider.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            pitchVal.innerText = val > 0 ? `+${val}` : val;
            updatePitch(val);

            // Unset presets visuals if manual change?
            presetBtns.forEach(b => b.classList.remove('active'));
        });

        function updatePitch(semitones) {
            targetPitch = semitones;
        }

        // Echo Slider
        echoSlider.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            echoVal.innerText = Math.round(val * 100) + "%";

            if (delayNode) {
                if (val === 0) {
                    delayNode.delayTime.setTargetAtTime(0, audioCtx.currentTime, 0.1);
                    delayFeedback.gain.setTargetAtTime(0, audioCtx.currentTime, 0.1);
                } else {
                    delayNode.delayTime.setTargetAtTime(0.3, audioCtx.currentTime, 0.1); // Fixed 300ms
                    delayFeedback.gain.setTargetAtTime(val, audioCtx.currentTime, 0.1);
                }
            }
        });

        // Robot Toggle
        robotToggle.addEventListener('change', (e) => {
            if (window.setRobotEffect) {
                window.setRobotEffect(e.target.checked);
            }
        });

        // Gate Toggle (Visualization based mute?)
        gateToggle.addEventListener('change', (e) => {
            // Logic in visualizer loop
        });

        // Presets removed from here (moved to top with worklet for clarity)
        // listeners attached below


        presetBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                const key = btn.dataset.preset;
                applyPreset(key);

                // UI update
                presetBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            });
        });

        function applyPreset(name) {
            const p = presets[name];

            // Set Pitch
            pitchSlider.value = p.pitch;
            pitchVal.innerText = p.pitch;
            updatePitch(p.pitch);

            // Set Echo
            echoSlider.value = p.echo;
            echoVal.innerText = (p.echo * 100) + "%";
            // Trigger input event logic manually
            if (delayNode) {
                const val = p.echo;
                if (val === 0) {
                    delayNode.delayTime.value = 0;
                    delayFeedback.gain.value = 0;
                } else {
                    delayNode.delayTime.value = 0.25;
                    delayFeedback.gain.value = val;
                }
            }

            // Set Robot
            robotToggle.checked = p.robot;
            if (window.setRobotEffect) window.setRobotEffect(p.robot);

            // Set Formant Filter Chain
            if (loFilter && midFilter && hiFilter && p.eq) {
                loFilter.frequency.value = p.eq.lF;
                loFilter.gain.value = p.eq.lG;

                midFilter.frequency.value = p.eq.mF;
                midFilter.gain.value = p.eq.mG;

                hiFilter.frequency.value = p.eq.hF;
                hiFilter.gain.value = p.eq.hG;
            }
        }

        // --- Recording ---
        recordBtn.addEventListener('click', () => {
            if (!recorder) return;

            if (isRecording) {
                // Stop
                recorder.stop();
                isRecording = false;
                recordBtn.innerText = "Start Recording";
                recordBtn.classList.remove('recording');
                downloadBtn.disabled = false;
            } else {
                // Start
                recordedChunks = [];
                audioPlayer.style.display = 'none';
                if (audioCtx.state === 'suspended') audioCtx.resume();

                recorder.start();
                isRecording = true;
                recordBtn.innerText = "Stop Recording";
                recordBtn.classList.add('recording');
                downloadBtn.disabled = true;
            }
        });

        function exportRecording() {
            const blob = new Blob(recordedChunks, { type: 'audio/webm' }); // WebM is standard for MediaRecorder
            const url = URL.createObjectURL(blob);
            audioPlayer.src = url;
            audioPlayer.style.display = 'block';

            downloadBtn.onclick = () => {
                const a = document.createElement('a');
                a.href = url;
                a.download = `voice-morph-${Date.now()}.webm`;
                a.click();
            };
        }

        // --- Visualizer & Gate Logic ---
        function drawVisualizer() {
            requestAnimationFrame(drawVisualizer);
            if (!analyser) return;

            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteTimeDomainData(dataArray);

            // Gate Logic
            let sum = 0;
            for (let i = 0; i < bufferLength; i++) {
                sum += Math.abs(dataArray[i] - 128);
            }
            const average = sum / bufferLength;

            // Simple noise gate behavior
            if (gateToggle.checked) {
                // Threshold ~ 5-10
                if (average < 5) {
                    // Mute output if below threshold
                    gainNode.gain.setTargetAtTime(0, audioCtx.currentTime, 0.05);
                } else {
                    gainNode.gain.setTargetAtTime(1, audioCtx.currentTime, 0.05);
                }
            } else {
                gainNode.gain.setTargetAtTime(1, audioCtx.currentTime, 0.1);
            }

            // Draw
            canvasCtx.fillStyle = '#1e1e1e';
            canvasCtx.fillRect(0, 0, canvas.width, canvas.height);

            canvasCtx.lineWidth = 2;
            canvasCtx.strokeStyle = '#bb86fc';
            canvasCtx.beginPath();

            const sliceWidth = canvas.width * 1.0 / bufferLength;
            let x = 0;

            for (let i = 0; i < bufferLength; i++) {
                const v = dataArray[i] / 128.0;
                const y = v * canvas.height / 2;

                if (i === 0) canvasCtx.moveTo(x, y);
                else canvasCtx.lineTo(x, y);

                x += sliceWidth;
            }

            canvasCtx.lineTo(canvas.width, canvas.height / 2);
            canvasCtx.stroke();
        }

    </script>
</body>

</html>